name: Deploy to Server

on:
  push:
    branches: [ master ]
  workflow_dispatch:

jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup SSH key
      uses: webfactory/ssh-agent@v0.7.0
      with:
        ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}

    - name: Add server to known hosts
      run: |
        echo "Adding server ${{ secrets.SERVER_HOST }} to known hosts..."
        ssh-keyscan -H ${{ secrets.SERVER_HOST }} >> ~/.ssh/known_hosts
        echo "Known hosts updated successfully"

    - name: Test SSH connection
      run: |
        echo "Testing SSH connection to ${{ secrets.SSH_USER }}@${{ secrets.SERVER_HOST }}..."
        ssh -o ConnectTimeout=10 ${{ secrets.SSH_USER }}@${{ secrets.SERVER_HOST }} "echo 'SSH connection successful'"

    - name: Create deployment directory
      run: |
        ssh ${{ secrets.SSH_USER }}@${{ secrets.SERVER_HOST }} "mkdir -p ${{ secrets.DEPLOY_PATH }}"

    - name: Copy project files to server
      run: |
        scp -r ./* ${{ secrets.SSH_USER }}@${{ secrets.SERVER_HOST }}:${{ secrets.DEPLOY_PATH }}/

    - name: Create production .env file
      run: |
        ssh ${{ secrets.SSH_USER }}@${{ secrets.SERVER_HOST }} << 'EOF'
          cd ${{ secrets.DEPLOY_PATH }}

          # Create .env file with GitHub secrets
          cat > .env << EOL
        API_KEY=${{ secrets.API_KEY }}
        REDIS_URL=redis://localhost:6379/0
        DATABASE_URL=${{ secrets.DATABASE_URL }}
        EOL

          chmod 600 .env
        EOF

    - name: Deploy application
      run: |
        ssh ${{ secrets.SSH_USER }}@${{ secrets.SERVER_HOST }} << 'EOF'
          cd ${{ secrets.DEPLOY_PATH }}

          # Create required directories for nginx and certbot
          mkdir -p nginx certbot/conf certbot/www scripts

          # Make scripts executable
          chmod +x scripts/*.sh

          # Stop existing containers
          docker compose down || true

          # Build and start new containers
          docker compose up -d --build

          # Wait for services to be ready
          sleep 10

          # Check if containers are running
          docker compose ps

          # Clean up unused images
          docker image prune -f

          echo "âœ… Deployment completed successfully!"
        EOF

    - name: Setup SSL certificates (first time only)
      run: |
        ssh ${{ secrets.SSH_USER }}@${{ secrets.SERVER_HOST }} << 'EOF'
          cd ${{ secrets.DEPLOY_PATH }}

          # Check if SSL certificate already exists
          if [ ! -f "/etc/letsencrypt/live/api.loralink.live/fullchain.pem" ]; then
            echo "ðŸ”’ SSL certificate not found, setting up SSL..."

            # Update email in SSL script if provided
            if [ ! -z "${{ secrets.SSL_EMAIL }}" ]; then
              sed -i 's/your-email@example.com/${{ secrets.SSL_EMAIL }}/g' scripts/init-ssl.sh
            fi

            # Run SSL setup script
            if bash scripts/init-ssl.sh; then
              echo "âœ… SSL setup completed successfully!"

              # Setup SSL renewal cron job
              echo "Setting up SSL renewal cron job..."
              (crontab -l 2>/dev/null; echo "0 0,12 * * * cd ${{ secrets.DEPLOY_PATH }} && bash scripts/renew-ssl.sh") | crontab -
              echo "âœ… SSL renewal cron job installed"
            else
              echo "âŒ SSL setup failed"
              echo "You can manually run: bash scripts/init-ssl.sh"
            fi
          else
            echo "âœ… SSL certificate already exists, skipping SSL setup"

            # Ensure renewal cron job exists
            if ! crontab -l 2>/dev/null | grep -q "renew-ssl.sh"; then
              echo "Adding SSL renewal cron job..."
              (crontab -l 2>/dev/null; echo "0 0,12 * * * cd ${{ secrets.DEPLOY_PATH }} && bash scripts/renew-ssl.sh") | crontab -
              echo "âœ… SSL renewal cron job installed"
            fi
          fi
        EOF